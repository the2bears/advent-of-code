(ns a-o-c-2022.day7
  (:require [clojure.java.io :as io]
            [clojure.string :as str]
            [clojure.set :as set]
            [a-o-c-2022.graph :as graph]))


(comment "https://adventofcode.com/2022/day/7")

(def test-data
  "$ cd /
$ ls
dir a
14848514 b.txt
8504156 c.dat
dir d
$ cd a
$ ls
dir e
29116 f
2557 g
62596 h.lst
$ cd e
$ ls
584 i
$ cd ..
$ cd ..
$ cd d
$ ls
4060174 j
8033020 d.log
5626152 d.ext
7214296 k")

(def file-system { :/ {:a {:b 100 :c.txt 800}}})

(def root-folder (update-in {} [:/] merge {}))

(def data
  (-> (slurp (io/resource "day7.txt"))))

(defn prep-data
  "Splits the lines by spaces and file sizes are converted to ints"
  [d]
  (-> d
      str/split-lines
      (->> (map #(str/split % #" "))
           (map #(mapv (fn[s]
                         (if (number? (read-string s))
                           (read-string s)
                           s))
                       %)))))

(defn add-file [fs path file size]
  (update-in fs path merge {file size}))
  
(defn add-folder [fs path folder]
  (update-in fs (conj path folder) merge {}))

(defn cd-command [path folder]
  (cond
    (= :.. folder) (into [] (drop-last path))
    :else (conj path folder)))

(defn exec-command [command path]
  (cond (= "cd" (second command)) (cd-command path (keyword (last command)))
        (= "ls" (second command)) path))

(defn is-file? [fs path]
  (number? (get-in fs path)))

(defn keys-in
  "Returns a sequence of all key paths in a given map using DFS walk."
  [m]
  (letfn [(children [node]
            (let [v (get-in m node)]
              (if (map? v)
                (map (fn [x] (conj node x)) (keys v))
                [])))
          (branch? [node]
            (let [v (get-in m node)]
              (map? v)))]
    (->> (keys m)
         (map vector)
         (mapcat #(tree-seq branch? children %)))))

(defn run-commands [commands]
  (loop [fs {}
         path []
         commands commands]
    (if (not (seq commands))
      fs
      (let [command (first commands)]
            ;;_ (prn (str "command " command ", path " path))]
        (cond
          (= "$" (first command))
          (recur fs (exec-command command path) (rest commands))
          (number? (first command))
          (recur (add-file fs
                           path
                           (second command)
                           (first command))
                 path
                 (rest commands))
          (= "dir" (first command))
          (recur (add-folder fs path (keyword (second command))) path (rest commands))
          :else
          (recur fs path (rest commands)))))))


(def t (run-commands (prep-data test-data)))

(defn find-folders
  "Takes a list generated by 'keys-in'"
  [s]
  (filter #(keyword? (last %)) s))

(defn folder-size [fs folder]
  (let [contents (get-in fs folder)]
        ;;_ (prn (str "contents " contents))]
    (reduce (fn[acc n]
              (if (is-file? fs (conj folder n))
                (+ acc (get-in fs (conj folder n)))
                (+ acc (folder-size fs (conj folder n)))))
            0
            (keys contents))))

(defn part1-fn [d max]
  (let [fs (-> d
               prep-data
               run-commands)
        folders (-> fs
                    keys-in
                    find-folders)]
    (->> (map #(folder-size fs %) folders)
         (filter #(<= % max))
         (apply +))))

(defn part2-fn [d needed fs-total]
  (let [fs (-> d
               prep-data
               run-commands)
        folders (-> fs
                    keys-in
                    find-folders)
        used-space (folder-size fs [:/])
        available-space (- fs-total used-space)
        find-space (- needed available-space)]
    (->> (map #(assoc {} % (folder-size fs %)) folders)
         (filter (fn[t]
                   (>= (second (first t)) find-space)))
         (map #(second (first %)))
         sort
         first)))
              
  
